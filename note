#!/bin/bash

PGNAME="tman-note"
VERSION="v0.0.1"
TASKDIR=
ARG_ENV=
ARG_DESK=
ARG_TASK=
REPO_STORE=     # where to store repos (should be inside taskdir)
NOTE_BASE=      # where notes are stored

# TODO: add option for config path on CLI
CONFIG_FILE=

function die() {
	echo "$PGNAME:" "$@" >&2
	exit 1
}

function find_config()
{
    declare -a cfgs=(
        "$HOME/.tec/pgn/note.json"
        "$HOME/.config/tec/pgn/note.json"
    )

    for cfg in "${cfgs[@]}"; do
        if [ -f "$cfg" ]; then
            CONFIG_FILE="$cfg"
            break
        fi
    done
}

function get_and_check_board()
{
    local curr=
    local fname="$TASKDIR/$ARG_ENV/.tec/toggles"

    if [ -f "$fname" ]; then
        curr="$(grep -i curr "$fname" | cut -f 2 -d '=' | tr -d ' ')"
    fi

    if [ -z "$ARG_DESK" ]; then
        ARG_DESK="$curr"
    fi

    # check project name
    if [ -z "$ARG_DESK" ]; then
        die "no board name is passed"
    elif [ ! -d "$TASKDIR/$ARG_ENV/$ARG_DESK" ]; then
        die "'$ARG_DESK': no such board name"
    fi
}

function get_and_check_task()
{
    local curr=
    local fname="$TASKDIR/$ARG_ENV/$ARG_DESK/.tec/toggles"

    if [ -f "$fname" ]; then
        curr="$(grep -i curr "$fname" | cut -f 2 -d '=' | tr -d ' ')"
    fi

    if [ -z "$ARG_TASK" ]; then
        ARG_TASK="$curr"
    fi

    # check project name
    if [ -z "$ARG_TASK" ]; then
        die "no task ID is passed"
    elif [ ! -d "$TASKDIR/$ARG_ENV/$ARG_DESK/$ARG_TASK" ]; then
        die "'$ARG_TASK': no such task ID"
    fi
}

function get_and_check_project()
{
    local curr=
    local fname="$TASKDIR/.tec/toggles"

    if [ -f "$fname" ]; then
        curr="$(grep -i curr "$fname" | cut -f 2 -d '=' | tr -d ' ')"
    fi

    if [ -z "$ARG_ENV" ]; then
        ARG_ENV="$curr"
    fi

    # check project name
    if [ -z "$ARG_ENV" ]; then
        die "no project name is passed"
    elif [ ! -d "$TASKDIR/$ARG_ENV" ]; then
        die "'$ARG_ENV': no such project name"
    fi
}

function _note_check_args()
{
    get_and_check_project
    get_and_check_board
    get_and_check_task
}

# Generate a unique task ID
generate_id() {
    local taskid_limit=1000
    local base="$TASKDIR/$ARG_ENV/.tec/pgn/note"

    if [ ! -f "$base" ]; then
        touch "$base"
    fi

    for taskid in $(seq -w "$taskid_limit"); do
        if ! grep -q "$taskid :" "$base"; then
            echo "$taskid"
            return 0
        fi
    done

    die "task ID limit is reached. There are $taskid_limit already"
    return 1
}


function _note_init() {
    mkdir -p "$TASKDIR/$ARG_ENV/.tec/pgn/"
    NOTE_BASE="$TASKDIR/$ARG_ENV/.tec/pgn/note"
}


note_add() {
    local ID=

    for arg in "${@}"; do
        echo "arg: $arg"
    done

    ID="$(generate_id)"
    read -p "Enter note: " -r input
    echo "$ID : $input" >> "$TASKDIR/$ARG_ENV/.tec/pgn/note"
}

note_cat() {
    echo "note_cat: under develoment"
    for arg in "${@}"; do
        echo "arg: $arg"
    done
}

note_help() {
    cat << EOF
Usage: tec note [COMMAND]

    add     - add a note
    cat     - show a note
    help    - show this help message and exit
    ls      - list notes
    rm      - remove a note
    set     - set title and/or body of note
EOF
}

note_ls() {
    if [ -f "$NOTE_BASE" ]; then
        cat "$NOTE_BASE"
    fi
}

note_rm() {
    local noteid="$1"; shift

    if [ -z "$noteid" ]; then
        die "specify note ID"
    elif ! grep -q "$noteid : " "$NOTE_BASE"; then
        die "'$noteid': no such note ID"
    fi

    sed -iE "/^$noteid/d" "$NOTE_BASE"
}

note_set() {
    # TODO:
    # 1. Use separate file for each note .pgn/note/NOTE-ID/
    # 2. Use this command to edit title (e.i. first line)
    # 3. Add empty line
    # 4. Add body of the note
    NOTE_BASE="$TASKDIR/$ARG_ENV/.tec/pgn/note"

    if [ -f "$NOTE_BASE" ]; then
        eval "$EDITOR" "$NOTE_BASE"
    fi
}

# Driver part of the code
OPTS=$(getopt -o d:i:e:P:T:hV --long desk:,debug,env:,taskid:,pgndir:,taskdir:help,version -n "$PGNAME" -- "$@")
if [ $? -ne 0 ]; then
    #echo "error parsing options" >&2
    exit 1
fi

## Reset the positional parameters to the parsed options
eval set -- "$OPTS"

while true; do
    case "$1" in
        -d)
            ARG_DESK="$2"
            shift 2
            ;;
        -e)
            ARG_ENV="$2"
            shift 2
            ;;
        -i)
            ARG_TASK="$2"
            shift 2
            ;;
        -P)
            PGNDIRBASE="$2"
            shift 2
            ;;
        -T)
            TASKDIR="$2"
            shift 2
            ;;
        -V)
            echo "$PGNAME: $VERSION"
            exit 0
            ;;
        --)
            shift
            break
            ;;
        *)
            elog "invalid option '$1'"
            exit 1
    esac
done


note() {
    local command=

    [ $# -eq 0 ] && set -- "ls" # set default command
    command="$1"; shift

    # TODO: move it to a function
    # Setup some stuff
    REPO_STORE="$TASKDIR/.pgn/note"

    _note_check_args
    _note_init

    case "$command" in
        add)      note_add "$@" ;;
        cat)      note_cat "$@" ;;
        help)     note_help "$@" ;;
        ls)       note_ls "$@" ;;
        rm)       note_rm "$@" ;;
        set)      note_set "$@" ;;
        *)        die "'$command': no such command"
    esac
}

note "$@"
