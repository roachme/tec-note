#!/bin/env lua

-- TODO: add support for current env, note ID, etc


local Program = "tec-note"
local Version = "v0.0.1"

local Arg = {}
Arg.__index = Arg
local Note = {}

local lfs = require("lfs")
local getopt = require("posix.unistd").getopt

local function elog(status, fmt, ...)
    io.stderr:write(string.format("%s " .. fmt .. "\n", Program, ...))
    return status
end

local function die(status, fmt, ...)
    elog(status, fmt, ...)
    os.exit(status)
end

local function generate_note_id(args)
    local limit = 1000
    local padding = "4" -- cuz limit is 1000, i.e. 4 digits
    local dirname = args.taskdir .. "/" .. args.env .. "/" .. ".tec/pgn/note"

    for i = 1, limit do
        local note_id = string.format("%0" .. padding .. "d", i)
        local fname = dirname .. "/" .. note_id
        local attr = lfs.attributes(fname)
        if not attr then
            return note_id
        end
    end
    return die(1, "note ID limit is %s", limit)
end

local helpmsgs = {
    {
        name = "note",
        msg =
[[
Usage: tec note [OPTION]... [COMMAND] [ARG]...
    Note taking plugin

    Commands:
      add      - add a new note
      cat      - show note
      ed       - edit title or body
      help     - get help on commands
      ls       - list of note
      mv       - move or rename note ID
      rm       - remove note
      set      - set note column and metadata
      ver      - show version ]]
    },
    {
        name = "add",
        msg =
[[
Usage: tec note add [OPTION]... [ID]...
    Add a new note
    If ID is not passed the note ID is generated.

    Options:
      -b MSG    body message
      -t MSG    title message

    Return value: ]]
    },
    {
        name = "cat",
        msg =
[[
Usage: tec note cat [OPTION]... [ID]...
    Show note

    Options

    Return value: ]]
    },
    {
        name = "ed",
        msg =
[[
Usage: tec note ed [OPTION]... [ID]...
    Edit note message

    Options:
      -i        open editor to make changes
      -b MSG    pass body message
      -t MSG    pass title message

    Return value: ]]

    },
    {
        name = "help",
        msg =
[[
Usage: tec note help [OPTION]... [ID]...
    Show help messages

    Options:

    Return value: ]]
    },
    {
        name = "ls",
        msg =
[[
Usage: tec note ls [OPTION]... [ENV]...
    Show list of notes

    Options:

    Return value: ]]
    },
    {
        name = "mv",
        msg =
[[
Usage: tec note mv [OPTION]... SRC DST
    Move or rename note ID

    Options:

    Return value: ]]
    },
    {
        name = "rm",
        msg =
[[
Usage: tec note rm [OPTION]... [ID]...
    Remove note

    Options:
      -f        ignore nonexistent note IDs, never prompt

    Return value: ]]
    },
    {
        name = "set",
        msg =
[[
Usage: tec note set [OPTION]... [ID]...
    Set column and metadata

    Options:

    Return value: ]]
    },
    {
        name = "ver",
        msg =
[[
Usage: tec note ver
    Show plugin version

    Return value: always return 0 ]]
    },
}

function Arg:new()
    local obj = {}
    setmetatable(obj, self)
    return obj
end

-- TODO: write an implementation
function Arg:get_env_curr()
    local buf
    local file = io.open(self.taskdir .. "/" .. ".tec/toggles")

    if file then
        buf = file:read("*l") or ""
        buf = string.match(buf, "=(.+)")
        self.curr_env = buf
        file:close()
    end

    return self.curr_env
end

-- TODO: write an implementation
function Arg:get_id_curr()
    -- TODO: add support for current and previous note IDs
    return self.curr_id
end

function Arg:env_valid(env)
    return env == string.match(env, "%w+")
end

function Arg:env_exist(env)
    local fname = self.taskdir .. "/" .. env .. "/" .. ".tec/pgn/note"
    local attr = lfs.attributes(fname)
    return attr ~= nil and attr.mode == "directory"
end

function Arg:env_check()
    self.env = self.env or self:get_env_curr()

    -- TOOD: check that passed env is valid and exists
    if not self.env then
        return die(1, "no current env")
    elseif not self:env_valid(self.env) then
        return die(1, "'%s': invalid env name", self.env)
    end
    return 0
end

function Arg:check_id(id)
    self.id = id or self:get_id_curr()

    -- TOOD: check that passed id is valid and exists
    if not self.id then
        return die(1, "no current id")
    end
end

function Arg:id_valid(id)
    return id == string.match(id, "%w+")
end

function Arg:id_exist(id)
    local dirname = self.taskdir .. "/" .. self.env .. "/" .. ".tec/pgn/note"
    local fname = dirname .. "/" .. id
    local attr = lfs.attributes(fname)
    return attr ~= nil and attr.mode == "file"
end


function Note._get_head(fname)
    local head
    local file = io.open(fname)

    if not file then
        return nil
    end

    head = file:read("*l")
    file:close()
    return head
end

function Note._set_head(fname, msg)
    local file = io.open(fname, "w")

    if not file then
        return die(1, "'%s': could not create a note file", fname)
    end

    file:write(msg, "\n")
    file:close()
end

function Note._set_tail(fname, msg)
    local file = io.open(fname, "a+")

    if not file then
        return die(1, "'%s': could not open a note file", fname)
    end

    file:write("\n", msg, "\n")
    file:close()
end

function Note._get_tail(fname)
    local _, tail
    local file = io.open(fname)

    if not file then
        return die(1, "'%s': no such note file", fname)
    end

    _ = file:read("*l") -- skip title
    _ = file:read("*l") -- skip empty line

    tail = file:read("*a") or ""
    file:close()
    return tail
end

function Note.init()
end

function Note.add(args)
    local lastind = 1
    local is_interactive = true
    local is_head = false
    local is_tail = false
    local dirname = args.taskdir .. "/" .. args.env .. "/" .. ".tec/pgn/note"

    local title, body

    -- TODO: add option `-i' to add note interactively
    for optopt, optarg, optind in getopt(arg, ":t:b:") do
        if optopt == '?' then
            return die(1, "'%s': unrecognized option", arg[optind - 1])
        end

        if optopt == 't' then
            is_interactive = false
            is_head = true
            title = optarg
        elseif optopt == 'b' then
            is_interactive = false
            is_tail = true
            body = optarg
        end
        lastind = optind
    end

    -- HOTFIX?: set current env if none passed
    if #arg == 0 then
        table.insert(arg, generate_note_id(args))
    end

    -- TODO: generate note ID
    for i = lastind, #arg do
        if not args:id_valid(arg[i]) then
            print("not a valid id: ", arg[i])
        elseif args:id_exist(arg[i]) then
            print("note id already exists: ", arg[i])
        else
            if is_interactive == true then
                io.write("Title: ")
                title = io.read()
                Note._set_head(dirname .. "/" .. arg[i], title)
            end

            if is_head then
                print("add: add a title to file")
                Note._set_head(dirname .. "/" .. arg[i], title)
            end
            if is_tail then
                print("add: add a body to file")
                Note._set_tail(dirname .. "/" .. arg[i], body)
            end
        end
    end
end

function Note.cat(args)
    local status = 0
    local lastind = 1
    local dirname = args.taskdir .. "/" .. args.env .. "/" .. ".tec/pgn/note"

    if #arg == 0 and not args:get_id_curr() then
        return elog(1, "'NOCURR': no current note ID")
    end

    for i = lastind, #arg do
        if not args:id_valid(arg[i]) then
            elog(1, "'%s': invalid note id", arg[i])
        elseif not args:id_exist(arg[i]) then
            elog(1, "'%s': no such note ID", arg[i])
        else
            io.write(Note._get_tail(dirname .. "/" .. arg[i]))
        end
    end
    return status
end

function Note.ed(args)
    local lastind = 1
    local is_interactive = true
    local is_head = false
    local is_tail = false
    local dirname = args.taskdir .. "/" .. args.env .. "/" .. ".tec/pgn/note"

    local title, body

    if #arg == 0 and not args:get_id_curr() then
        return elog(1, "'NOCURR': no current note ID")
    end

    for optopt, optarg, optind in getopt(arg, ":it:b:") do
        if optopt == '?' then
            return die(1, "'%s': unrecognized option", arg[optind - 1])
        end

        -- TODO: option 'i'nteractive -> open editor
        if optopt == 'i' then
            is_interactive = true
            is_head = false
            is_tail = false
        elseif optopt == 't' then
            is_interactive = false
            is_head = true
            title = optarg
        elseif optopt == 'b' then
            is_interactive = false
            is_tail = true
            body = optarg
        end
        lastind = optind
    end

    -- TODO: generate note ID
    for i = lastind, #arg do
        if not args:id_valid(arg[i]) then
            elog(1, "'%s': invalid note id", arg[i])
        elseif not args:id_exist(arg[i]) then
            elog(1, "'%s': no such note ID", arg[i])
        else
            if is_interactive == true then
                -- TODO: open editor to make changes
                os.execute("$EDITOR " .. dirname .. "/" .. arg[i])
            end
            if is_head then
                print("ed: edit a title to file: under development cuz body might get lost")
                --Note._set_head(dirname .. "/" .. arg[i], title)
            end
            if is_tail then
                print("ed: edit a body to file: under development cuz head might get lost")
                --Note._set_tail(dirname .. "/" .. arg[i], body)
            end
        end
    end
end

function Note.help(args)
    local cmd = arg[1] or "note"

    for _, msg in pairs(helpmsgs) do
        if cmd == msg.name then
            print(msg.msg)
            return 0
        end
    end
    return die(1, "'%s': no such command to show help message", cmd)
end

function Note.ls(args)
    local status = 0
    local lastind = 1
    local fmt = "%-10s %s"

    -- HOTFIX?: set current env if none passed
    if #arg == 0 then
        table.insert(arg, args.env)
    end

    for i = lastind, #arg do
        local dirname = args.taskdir .. "/" .. arg[i] .. "/" .. ".tec/pgn/note"

        if not args:env_valid(arg[i]) then
            status = elog(1, "'%s': invalid env name", arg[i])
        elseif not args:env_exist(arg[i]) then
            status = elog(1, "'%s': no such env", arg[i])
        else
            for entry in lfs.dir(dirname) do
                local fname = dirname .. "/" .. entry
                local attr = lfs.attributes(fname)

                if attr.mode == "file" then
                    local head = Note._get_head(fname)
                    print(string.format(fmt, entry, head))
                end
            end
        end
    end
    return status
end

function Note.mv(args)
    local status = 0
    return status
end

function Note.rm(args)
    local choice, fname
    local lastind = 1
    local force = false
    local dirname = args.taskdir .. "/" .. args.env .. "/" .. ".tec/pgn/note"

    if #arg == 0 and not args:get_id_curr() then
        return elog(1, "'NOCURR': no current note ID")
    end

    for optopt, optarg, optind in getopt(arg, ":f") do
        if optopt == '?' then
            return die(1, "'%s': unrecognized option", arg[optind - 1])
        end
        lastind = optind

        if optopt == 'f' then
            force = true
        end
    end

    for i = lastind, #arg do
        if not args:id_valid(arg[i]) then
            if force == false then
                elog(1, "'%s': invalid note id", arg[i])
            end
        elseif not args:id_exist(arg[i]) then
            if force == false then
                elog(1, "'%s': no such note ID", arg[i])
            end
        else
            fname = dirname .. "/" .. arg[i]
            if force == false then
                io.write(string.format("remove note file '%s'? ", arg[i]))
                choice = io.read()
                if choice == 'y' or choice == 'yes' then
                    os.remove(fname)
                end
            else
                os.remove(fname)
            end
        end
    end
end

-- Set column and metadata
function Note.set(args)
    local status = 0

    if #arg == 0 and not args:get_id_curr() then
        return elog(1, "'NOCURR': no current note ID")
    end

    return status
end

function Note.ver()
    print(string.format("%s: %s", Program, Version))
end

local Commands = {
    { name = "add", func = Note.add },
    { name = "cat", func = Note.cat },
    { name = "ed", func = Note.ed },
    { name = "help", func = Note.help },
    { name = "ls", func = Note.ls },
    { name = "mv", func = Note.mv },
    { name = "rm", func = Note.rm },
    { name = "set", func = Note.set },
    { name = "ver", func = Note.ver },
}

local function main()
    local lastind = 1
    local command = nil
    local args = Arg:new()
    local opt_help = false
    local opt_version = false

    for optopt, optarg, optind in getopt(arg, ":d:e:hi:P:T:v") do
        if optopt == '?' then
            return die(1, "'%s': unrecognized option", arg[optind - 1])
        end
        lastind = optind

        if optopt == 'd' then
            Arg.desk = optarg
        elseif optopt == 'e' then
            Arg.env = optarg
        elseif optopt == 'h' then
            opt_help = true
        elseif optopt == 'i' then
            Arg.taskid = optarg
        elseif optopt == 'P' then
            Arg.pgndir = optarg
        elseif optopt == 'T' then
            Arg.taskdir = optarg
        elseif optopt == 'v' then
            opt_version = true
        end
    end
    for _ = 1, lastind - 1 do
        table.remove(arg, 1)
    end

    command = table.remove(arg, 1) or "ls"

    if opt_help == true then
        command = "help"
    elseif opt_version == true then
        command = "ver"
    end

    -- TODO: Get currents and check them
    args:env_check()

    for _, cmd in pairs(Commands) do
        if command == cmd.name then
            return cmd.func(args)
        end
    end
    return die(1, "'%s': no such command", command)
end

os.exit(main())
